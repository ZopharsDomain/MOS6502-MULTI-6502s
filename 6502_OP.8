; ************************************************************************
; ************************************************************************
;
;       Opcodes that aren't automatically generated by OPGEN.C
;
; ************************************************************************
; ************************************************************************

____:   dec     bp                      ; point to the instruction
        CPUCrash                        ; no operation - illegal
        ret

__00:   mov     ax,bp                   ; 00 - brk
        rpush   ah                      ; push return address on stack
        rpush   al
        call    UpdateFlagBits          ; make the flag register current
        setf    BFlag
        rpush   ch                      ; push the processor status

        mov     bx,0FFFEh               ; jump indirect to bx
        call    JumpIndirect
        ret

__08:   call    UpdateFlagBits          ; 08 - push flags
        rpush   ch
        ret

__20:   fetchaddr                       ; 20 - call subroutine
        push    ax
        dec     bp                      ; push pc - 1 on the stack
        mov     ax,bp
        rpush   ah                      ; do it now !
        rpush   al
        pop     bp                      ; and transfer control to given addr.
        ret

__24:   eac_zero                        ; 24 - Bit test,zero page
        readz   al
        jmp     BitCode
 
__28:   rpop    ch                      ; 28 - pop flags
        call    UpdateByteRegisters     ; set the z and n bytes
        setf    BFlag
        ret

__2c:   eac_abs                         ; 28 - Bit test,absolute
        read    al
BitCode:mov     ah,al                   ; value in ah
        and     ah,cl                   ; and with the accumulator
        setz    ah                      ; set zero flag using this result
        and     ch,03Fh                 ; drop bits 6 & 7 of flags
        and     al,0C0h                 ; keep only bits 6 & 7 of the value
        or      ch,al                   ; do the bit test
        setn    al                      ; use the result to set N Byte Reg
        ret

__40:   rpop    ch                      ; 40 - return from interrupt
        call    UpdateByteRegisters     ; set the z and n bytes
        setf    BFlag
        rpop    al
        rpop    ah
        mov     bp,ax
        ret

__48:   rpush   cl                      ; 48 - push accumulator
        ret

__4c:   fetchaddr                       ; 4C - Jump
        mov     bp,ax
        ret

__60:   rpop    al                      ; 60 - return from subroutine
        rpop    ah
        inc     ax
        mov     bp,ax
        ret
 
__68:   rpop    cl                      ; 68 - pop accumulator
        setzn   cl
        ret

__6c:   fetchaddr                       ; 6C - Jump indirect
        mov     bx,ax
JumpIndirect:
        push    bx
        read    al                      ; read low byte of addr
        pop     bx
        inc     bl
        read    ah                      ; read high byte of addr
        mov     bp,ax                   ; and jump
        ret
 
__88:   mov     al,[_y]                 ; 88 - Dey
        alu_dec
        mov     [_y],al
        ret

__8a:   mov     cl,[_x]                 ; 8a - Txa
        setzn   cl
        ret

__98:   mov     cl,[_y]                 ; 98 - Tya
        setzn   cl
        ret
 
__9a:   mov     al,[_x]                 ; 9a - Txs
        mov     [_s],al
        ret

__a8:   mov     [_y],cl                 ; a8 - Tay
        setzn   cl
        ret

__aa:   mov     [_x],cl                 ; aa - Tax
        setzn   cl
        ret

__ba:   mov     al,[_s]                 ; ba - tsx
        mov     [_x],al
        setzn   al
        ret

__c8:   mov     al,[_y]                 ; c8 - Iny
        alu_inc
        mov     [_y],al
        ret

__ca:   mov     al,[_x]                 ; ca - Dex
        alu_dec
        mov     [_x],al
        ret

__e8:   mov     al,[_x]                 ; e8 - Inx
        alu_inc
        mov     [_x],al
        ret
 
__ea:   ret                             ; ea - Nop

; ************************************************************************
; ************************************************************************
;
;                       Routines used by macros
;
; ************************************************************************
; ************************************************************************

AddVector:dw    AddBinary
SubVector:dw    SubBinary

AddBinary:
        getcarry                        ; get the carry flag
        adc     cl,al                   ; do the addition
        jo      AddBin2                 ; go to the overflow bit
        setcarry                        ; get carry from the carry bit
        clearf  VFlag
        setzn   cl
        ret
AddBin2:setcarry
        setf    VFlag
        setzn   cl
        ret

AddDecimal:
        clearf  VFlag
        getcarry                        ; get the carry flag
        adc     cl,al                   ; do the addition
        mov     al,cl                   ; decimal adjust it
        daa
        mov     cl,al
        setcarry
        setzn   cl
        ret

SubBinary:
        getcarry                        ; get the carry flag
        cmc
        sbb     cl,al                   ; do the subtraction
        jo      SubBin2                 ; go to the overflow bit
        cmc
        setcarry                        ; get carry from the carry bit
        clearf  VFlag
        setzn   cl
        ret
SubBin2:cmc
        setcarry
        setf    VFlag
        setzn   cl
        ret

SubDecimal:
        clearf  VFlag
        getcarry                        ; get the carry flag
        cmc
        sbb     cl,al                   ; do the subtraction
        mov     al,cl                   ; decimal adjust it
        das
        mov     cl,al
        cmc
        setcarry
        setzn   cl
        ret

DoNMI:  mov     ax,bp
        rpush   ah                      ; push return address on stack
        rpush   al
        call    UpdateFlagBits          ; make the flag register current
        rpush   ch                      ; push the processor status
        mov     bx,0FFFAh               ; jump indirect to bx
        call    JumpIndirect
        ret

DoIRQ:
        test    ch,IFlag                ; check the interrupt flag....
        jnz     ret                     ; disabled
        mov     ax,bp
        rpush   ah                      ; push return address on stack
        rpush   al
        call    UpdateFlagBits          ; make the flag register current
        clearf  BFlag
        rpush   ch                      ; push the processor status
        setf    BFlag
        mov     bx,0FFFEh               ; jump indirect to bx
        call    JumpIndirect
        setf    IFlag                   ; set the interrupt disable flag
        ret

